function [frametimes, StimMovie] = show(stimuli, screenInfo, syncOut, waveOut, syncSquare, callbacks, FrameInterval, PixelInterval)%SHOW Shows visual stimuli and executes draw-synchronised callbacks% frametimes = SHOW(stimuli, screenInfo, [syncOut], [waveOut], [syncSquare], [callbacks])%% Plays each stimulus in the 'stimuli' object, on screen specified by% 'screenInfo', and returns the times of each stimulus frame flip.%% 'syncSquare' optionally lets you specify sync square parameters to% override those in screenInfo.%% The optional parameter 'callbacks' should be a struct with functions% in the fields: preStimFlip, stimFlip, and postStimFlip.% Each will be called following the relevant flips. Each should take a% parameter containing the psychtoolbox timestamp of the flip, and% postStimFlip should take a second parameter, the stimulus frame% number (1,2,3...).%% [frametimes, StimMovie] = show( ... ) returns a movie StimMovie of the% stimulus (CAUTION: this will run way slower)%% [frametimes, StimMovie] = show( a, b, c, d, e, f, FrameInterval, PixelInterval )% lets you specify an interval for frames and pixels when grabbing the% movie. Defaults are 1 and 1 (all frames, all pixels)%% Part of the Stimulus toolbox.% 2011-02 MC derived from oglStimPlay% 2011-04 MC disabled beeps because buggy and because they are a bad idea% 2013-02 MC added support for 64 bit data acquisition toolbox (but not yet for wave output)% 2013-07 DS added support for 64 bit wave output (startBackground takes some time..)% 2013-10 MK added support for 'HwDigital' ao triggertype (32-bit interface)%            it allows synchronizing the wave with the sync square% 2014-01 CB overhaulled:%  * DAQ sessions are initialised by caller (e.g. vs)%  * waveOut channels are (re)configured as required by stimulus waveforms%  * Graphics flip event callback support added%  * Parameter list has changed to allow the above%  * No longer acquires data (this wasn't used by VS anyway?)%  * Will now throw an error (rather than beep) if the texture preload failed%  * More comments throughout% 2015-11 MC added the ability to grab a movie% 2019-10 DS fixed texture color%% Basic initializationstartTime = tic;if nargin < 6 || isempty(callbacks)    callbacks = struct; % empty callbacks structendif nargin < 5 || isempty(syncSquare)    syncSquare = screenInfo.SyncSquare; % use ScreenInfo sync square by defaultendif nargin < 4    waveOut = [];endif nargin < 3    syncOut = [];endif nargin < 2    error('StimPlay:BadParameters', 'StimPlay needs at least two arguments');endVideoGrabbing = false;if nargout > 1    VideoGrabbing = true;    if nargin<7 || isempty(FrameInterval)        FrameInterval = 1; % don't skip any frames    end    if nargin<8 || isempty(PixelInterval)        PixelInterval = 1; % don't skip any pixels    endend% Notify and return immediately with empty stimulusif isempty(stimuli) || (stimuli.nFrames == 0 && isempty(stimuli.WaveStim) && isempty(stimuli.WaveSoundcard))    fprintf('--------------- Empty stimulus ----------------\n');    frametimes = [];    return % return immediatelyendwinPtr = screenInfo.windowPtr; % handle for the graphics window% set graphics blending dependent on stimuli.MinusOneToOne flag (this works% for single textures but not for multiple textures)minusOneToOneMode(screenInfo, stimuli.MinusOneToOne);% set use of alpha values (if stimuli.useAlpha == true, the following% command will overwrite settings made by minusOneToOneModeif stimuli.UseAlpha    Screen('BlendFunction', winPtr, GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);endsyncAngle = syncSquare.Angle; %30/7/20%prohibit alpha blending for syncsquare%Screen('BlendFunction', winPtr, GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA,[1 1 1 1]);%% Configure sync square state texturessyncRect = syncSquare.GetSyncRect(screenInfo); % sync square rectangle coords[prePostSyncTex, stimSyncTexs] = syncSquare.createTextures(screenInfo); % texuresstimSyncOutVals = screenInfo.SyncSquare.Sequence > 0.5;nStimSyncs = numel(stimSyncTexs); % countnWaveChans = prepareSessionForStimuli(waveOut, screenInfo, stimuli);% initialize sound card (don't forget to call InitializePsychSound first!if ~isempty(stimuli.WaveSoundcard); pahandle = prepareSoundcardforStimuli(stimuli); end%% Preallocate variables and load textures into VRAMpointerSequence = stimuli.GetPointerSequence;success = Screen('PreloadTextures', winPtr, unique(pointerSequence));if ~success,    error('Failed to preload textures! Low video memory.');end% get these out of the object so it is faster to access them:nFrames           = stimuli.nFrames;bgColour          = stimuli.BackgroundColor;sourceRects       = stimuli.SourceRects;destRects         = stimuli.DestRects;orientations      = stimuli.Orientations;bilinearFiltering = stimuli.BilinearFiltering;amplitudes        = stimuli.Amplitudes;if stimuli.BackgroundPersists    persistColor = bgColour;else        %persistColor = GrayIndex(screenInfo.WhichScreen); % gray        persistColor = screenInfo.BackgroundColor; % changed 2015-05-01 by NAS    endframetimes = zeros(nFrames + 1, 1);  % to record flip timesPriority(2); % Give a higher priority level to MATLAB processes%% Render pre-stim frameduration = toc(startTime);if VideoGrabbing, fprintf('*** VIDEO GRABBING IS ON. ALL TIMINGS WILL BE WRONG ***\n'); endfprintf('Playing visual stimulus & delivering %i waveforms (after %2.2f s of overhead)\n', nWaveChans, duration);Screen('FillRect', winPtr, bgColour(:).*screenInfo.ColorChannels2Use(:));   % fill the background colorScreen('DrawTexture', winPtr, prePostSyncTex, [], syncRect, syncAngle);frametimes(1) = Screen('Flip', winPtr);if ~isempty(syncOut)    % echo sync square state to syncOut    syncOut.outputSingleScan(syncSquare.PreAndPost > 0.5);endif isfield(callbacks, 'preStimFlip')    callbacks.preStimFlip(frametimes(1)); % call(ll.99) n pre-stim sync event handlerendif nWaveChans > 0    % start stimulus waveforms on waveOut    waveOut.startBackground();end% start soundif ~isempty(stimuli.WaveSoundcard); PsychPortAudio('Start', pahandle, 1, 0, 0); end%% Render sequence of stimulus frames% nFramesif VideoGrabbing, StimMovie = cell(nFrames,1); endfor iFrame = 1:nFrames    Screen('DrawTextures', ...        winPtr, ...        pointerSequence(:,iFrame), ...        sourceRects(:,:,iFrame), ...        destRects(:,:,iFrame), ...        orientations(:,iFrame), ...        bilinearFiltering, ...        amplitudes(:,iFrame), ...        255*screenInfo.ColorChannels2Use);%2/10/2019    %render sync square with current state texure    syncIdx = rem(iFrame - 1, nStimSyncs) + 1;    Screen('DrawTexture', winPtr, stimSyncTexs(syncIdx), [], syncRect, syncAngle);        %%merge stimulus and syncsquare ... STILL SHOWS YELLOW ON SYNCSQUARE%     Screen('DrawTextures', winPtr, [pointerSequence(:,iFrame); stimSyncTexs(syncIdx)], ...%         [sourceRects(:,:,iFrame) syncRect'], [destRects(:,:,iFrame) syncRect'])%         [orientations(:,:,iFrame) 0]);%     , [bilinearFiltering; bilinearFiltering], ...%         [amplitudes(:,iFrame) 1],...%         255*[screenInfo.ColorChannels2Use; 1 1 1]);            if VideoGrabbing && rem(iFrame+1,FrameInterval)==0        StimMovie{iFrame} = Screen('GetImage', winPtr, [], [], 0, 1);    end        frametimes(iFrame + 1) = Screen('Flip', winPtr); % flip and record the timestamp    % set sync out to appropriate value    if ~isempty(syncOut)        % echo sync square state to syncOut        syncOut.outputSingleScan(stimSyncOutVals(syncIdx));        stimSyncOutVals(syncIdx);    end    %     disp(stimSyncOutVals(syncIdx))    if isfield(callbacks, 'stimFlip')        callbacks.stimFlip(frametimes(iFrame + 1), iFrame); % call stim sync event handler    endend%% Render post-stim frameScreen('FillRect', winPtr, persistColor(:).*screenInfo.ColorChannels2Use(:));Screen('DrawTexture', winPtr, prePostSyncTex, [], syncRect, syncAngle);finalVBLTimeStamp = Screen('Flip', winPtr); % draw one last timeif ~isempty(syncOut)    % echo sync square state to syncOut    syncOut.outputSingleScan(syncSquare.PreAndPost > 0.5);endif isfield(callbacks, 'postStimFlip')    callbacks.postStimFlip(finalVBLTimeStamp); % call post-stim sync event handlerendif nWaveChans > 0    % wait for waveOut delivery to finish    waveOut.wait();    % make sure AO goes 0 after trial 2/10/20    waveOut.outputSingleScan(zeros(size(waveOut.Channels)));end%% CleanupPriority(0); % put MATLAB back to normal priority level%Delete the textures that we made for the sync squaresScreen('Close', [prePostSyncTex; stimSyncTexs]);% close audioif ~isempty(stimuli.WaveSoundcard)    PsychPortAudio('Stop', pahandle);    PsychPortAudio('Close', pahandle);    end%% Display status information%Calculate how much time it took to do all thisframetimes = frametimes - frametimes(1);elapsed = frametimes(end);ifi = Screen('GetFlipInterval', winPtr); % duration of monitor refresh intervalPredDurBasedOnGlobalFrameRate = stimuli.nFrames / screenInfo.FrameRate;PredDurBasedOnLocalFrameRate  = stimuli.nFrames * ifi;if ~VideoGrabbing    fprintf('Duration: %3.3f s -- Predictions: %3.3f based on local FrameRate, %3.3f based on overall FrameRate\n', ...        elapsed, PredDurBasedOnLocalFrameRate, PredDurBasedOnGlobalFrameRate);        if elapsed > PredDurBasedOnLocalFrameRate + ifi        fprintf('WARNING: should have been shorter by %3.1f ms\n',  1000*(elapsed-PredDurBasedOnGlobalFrameRate) );    end    if elapsed < PredDurBasedOnLocalFrameRate - ifi        fprintf('WARNING: should have been longer by %3.1f ms\n', -1000*(elapsed-PredDurBasedOnGlobalFrameRate) );    end        dts = diff(frametimes);        missedFrames = sum(dts > (1.05 * ifi)); % was 1.20 up to 2007-10-03, 1.05 up to 2009-09-23 (all changes by MC)    if missedFrames > 0,        fprintf('WARNING: Possible %d missed frames this repeat.\n', missedFrames);    end        duration = toc(startTime);    fprintf('... done (after %2.2f in total)\n', duration);end