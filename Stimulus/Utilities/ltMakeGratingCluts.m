function [Cluts, nCluts, actualTFreq] = ltMakeGratingCluts(SinPars,myscreen,reserveflag)% Utility that makes cluts for grating lut animation%% [Cluts, nCluts] = ltMakeGratingCluts(SinPars,myscreen)% reserves the first entry for gray%% [Cluts, nCluts] = ltMakeGratingCluts(SinPars,myscreen,'reserve3')% reserves the first 3 entries for gray, white, black%% [Cluts, nCluts, actualTFreq] = ltMakeGratingCluts(SinPars,myscreen) returns the% actual temporal frequency in Hertz%% if SinPars.direction = 0, makes cluts for counterphase flicker% if SinPars.direction = 1, makes a drifting grating going forward (default)% if SinPars.direction = -1, makes a drifting grating going backwards%% see the end of the code for an example of use%% Part of LabTools%% 1999 FH, TF, MC % 2001-03 MC made faster by replacing "mod" with "fastmod"% 2004-01 MC streamlined%            removed rounding after mod (may cause tiny spatial error)%            changed mod argument by 1 (there was a repeated entry)%            changed the way square waves are made%            added support for counterphase flicker% 2004-11 MC added temporal phase parameter%			 fixed bug in square waves% VM: I would have chosen 256 as second value of the lut, and 128 as the third% MC: If you reserve the first 3, then there are only 253 entries, so white is 253, gray is 129%% VM:% The first value of the lut (navailable/nCluts) depends on Clut.% This causes the (spatial) phase of the grating to be linearly related to% the temporal frequency of the grating, which is equivalent to a fixed% delay:% phi = navailable/nClut * 2pi/navailable% nClut = FR/tf (FR = frame rate, tf = true temporal frequency)% phi = 2pi * tf * 1/FR% Considering that the phase of a delay is: phi_delay = 2pi * tf * dt% one has dt = 1/FR% MC:% yes, this was an unfortunate choice. But I would not fix it or we would have to change all % the analysis files at this point...if nargin<3	reserveflag = '';endif ~isfield(SinPars,'Contrast')	SinPars.Contrast = 0.64;	disp('WARNING ------------------ No contrast defined. Using default.')endif ~isfield(SinPars,'tFreq')	SinPars.tFreq = 2;	disp('WARNING ------------------ No tFreq defined. Using default.')endif ~isfield(SinPars,'direction')	SinPars.direction = 1;		% +- 1 or 0 for flickerendif ~isfield(SinPars,'sqwv')	SinPars.sqwv = 0;endif ~isfield(SinPars,'TempPhase')	SinPars.TempPhase = 0;end% this is unnecessary now that we use objects, and in fact it crashes:% if ~isfield(myscreen,'FrameRate')% 	error('myscreen must have a FrameRate field');% endif strcmp(reserveflag,'reserve3')	nreserved= 3;else	nreserved= 1;endif SinPars.tFreq == 0    nCluts = 1;else    nCluts=round(myscreen.FrameRate/SinPars.tFreq);	% number of frames per cycleendactualTFreq=myscreen.FrameRate/nCluts; % calculate actual temporal freq (Hz)Cluts = zeros(nCluts,256,3);navailable = 256 - nreserved;meang = round(navailable/2); % the mean gray level% assign the reserved clutsCluts(:,1,:)=meang;if nreserved==3	Cluts(:,2,:)=navailable;	Cluts(:,3,:)=1;endif SinPars.direction == 0	% -------------- counterphase flickering ---------------	temp = [0:navailable-1]';	for iClut=1:nCluts		contrast = SinPars.Contrast*sin(2*pi*iClut/nCluts + SinPars.TempPhase);			% between -1 and 1		sinusoid = sin(2*pi*temp/navailable);					% between -1 and 1		if SinPars.sqwv==0			sinusoid = contrast*sinusoid;						else			sinusoid = contrast*sign(sinusoid); 		end				myclut = 1+(meang-1)*(1+sinusoid);							% between 1 and 2*meang-1 		Cluts(iClut,(nreserved+1):256,:)	= myclut*ones(1,3);	end  else	% ------------------ drifting --------------------------	for iClut=1:nCluts		startnum = iClut/nCluts*navailable; 							% this is what makes it move		temp = fastmod( startnum+[0:(navailable-1)], navailable )'; 	% between 0 and navailable-1		sinusoid = sin(2*pi*temp/navailable + SinPars.TempPhase);		% between -1 and 1		if SinPars.sqwv==0			sinusoid = SinPars.Contrast*sinusoid;				else			sinusoid = SinPars.Contrast*sign(sinusoid); 		end		myclut = 1+(meang-1)*(1+sinusoid);							% between 1 and 2*meang-1 		if SinPars.direction			Cluts(iClut,(nreserved+1):256,:)		= myclut*ones(1,3);		else			Cluts(iClut,256:-1:(nreserved+1),:)	= myclut*ones(1,3);		end	endendfunction z = fastmod(x,y)% FASTMOD is a faster version of modz = x - floor(x./y).*y;return%-----------------------------------------------------------------myscreen.FrameRate = 124.5;SinPars.Contrast = 0.5;SinPars.tFreq = 30;SinPars.direction = 0;[Cluts, nCluts, actualTFreq] = ltMakeGratingCluts(SinPars,myscreen,'reserve3');figure; for iClut = 1:nCluts, plot(Cluts(iClut,[4:end],1)); hold on; endaxis tight